diff --git content/browser/compositor/browser_compositor_output_surface.cc content/browser/compositor/browser_compositor_output_surface.cc
index d96efe91eea8..1345025b6fd8 100644
--- content/browser/compositor/browser_compositor_output_surface.cc
+++ content/browser/compositor/browser_compositor_output_surface.cc
@@ -62,6 +62,10 @@ void BrowserCompositorOutputSurface::SetReflector(ReflectorImpl* reflector) {
   OnReflectorChanged();
 }
 
+void* BrowserCompositorOutputSurface::GetSharedTexture() const {
+  return nullptr;
+}
+
 void BrowserCompositorOutputSurface::OnReflectorChanged() {
 }
 
diff --git content/browser/compositor/browser_compositor_output_surface.h content/browser/compositor/browser_compositor_output_surface.h
index 941d70bd2a7e..ef14a7dd7d4f 100644
--- content/browser/compositor/browser_compositor_output_surface.h
+++ content/browser/compositor/browser_compositor_output_surface.h
@@ -41,6 +41,8 @@ class CONTENT_EXPORT BrowserCompositorOutputSurface
 
   void SetReflector(ReflectorImpl* reflector);
 
+  virtual void* GetSharedTexture() const;
+
   // Called when |reflector_| was updated.
   virtual void OnReflectorChanged();
 
diff --git content/browser/compositor/gpu_process_transport_factory.cc content/browser/compositor/gpu_process_transport_factory.cc
index 97d3236bed17..910dbf64a931 100644
--- content/browser/compositor/gpu_process_transport_factory.cc
+++ content/browser/compositor/gpu_process_transport_factory.cc
@@ -215,6 +215,18 @@ GpuProcessTransportFactory::~GpuProcessTransportFactory() {
   task_graph_runner_->Shutdown();
 }
 
+void* GpuProcessTransportFactory::GetSharedTexture(ui::Compositor* compositor) {
+  PerCompositorDataMap::iterator it = per_compositor_data_.find(compositor);
+  if (it == per_compositor_data_.end())
+    return nullptr;
+  PerCompositorData* data = it->second.get();
+  DCHECK(data);
+
+  if (data->display_output_surface)
+    return data->display_output_surface->GetSharedTexture();
+  return nullptr;
+}
+
 std::unique_ptr<viz::SoftwareOutputDevice>
 GpuProcessTransportFactory::CreateSoftwareOutputDevice(
     gfx::AcceleratedWidget widget,
@@ -482,11 +494,20 @@ void GpuProcessTransportFactory::EstablishedGpuChannel(
         // surfaces as they are not following the correct mode.
         DisableGpuCompositing(compositor.get());
       }
+
+      std::unique_ptr<viz::SoftwareOutputDevice> output_device;
+      if (compositor->delegate()) {
+        output_device = compositor->delegate()->CreateSoftwareOutputDevice(
+            compositor.get());
+      }
+      if (!output_device) {
+        output_device = CreateSoftwareOutputDevice(compositor->widget(),
+                                                   compositor->task_runner());
+      }
+
       display_output_surface =
           std::make_unique<SoftwareBrowserCompositorOutputSurface>(
-              CreateSoftwareOutputDevice(compositor->widget(),
-                                         compositor->task_runner()),
-              std::move(vsync_callback));
+              std::move(output_device), std::move(vsync_callback));
     } else {
       DCHECK(context_provider);
       const auto& capabilities = context_provider->ContextCapabilities();
@@ -494,7 +515,8 @@ void GpuProcessTransportFactory::EstablishedGpuChannel(
         display_output_surface =
             std::make_unique<OffscreenBrowserCompositorOutputSurface>(
                 context_provider, std::move(vsync_callback),
-                std::unique_ptr<viz::CompositorOverlayCandidateValidator>());
+                std::unique_ptr<viz::CompositorOverlayCandidateValidator>(),
+                compositor->shared_texture_enabled());
       } else if (capabilities.surfaceless) {
 #if defined(OS_MACOSX)
         const auto& gpu_feature_info = context_provider->GetGpuFeatureInfo();
@@ -941,7 +963,8 @@ GpuProcessTransportFactory::CreatePerCompositorData(
   gfx::AcceleratedWidget widget = compositor->widget();
 
   auto data = std::make_unique<PerCompositorData>();
-  if (widget == gfx::kNullAcceleratedWidget) {
+  if (widget == gfx::kNullAcceleratedWidget ||
+      compositor->shared_texture_enabled()) {
     data->surface_handle = gpu::kNullSurfaceHandle;
   } else {
 #if defined(GPU_SURFACE_HANDLE_IS_ACCELERATED_WINDOW)
diff --git content/browser/compositor/gpu_process_transport_factory.h content/browser/compositor/gpu_process_transport_factory.h
index 5653f31a8797..910de72d1543 100644
--- content/browser/compositor/gpu_process_transport_factory.h
+++ content/browser/compositor/gpu_process_transport_factory.h
@@ -102,6 +102,7 @@ class GpuProcessTransportFactory : public ui::ContextFactory,
   void IssueExternalBeginFrame(ui::Compositor* compositor,
                                const viz::BeginFrameArgs& args) override;
   void SetOutputIsSecure(ui::Compositor* compositor, bool secure) override;
+  void* GetSharedTexture(ui::Compositor* compositor) override;
 
   // ImageTransportFactory implementation.
   void DisableGpuCompositing() override;
diff --git content/browser/compositor/offscreen_browser_compositor_output_surface.cc content/browser/compositor/offscreen_browser_compositor_output_surface.cc
index b5f5874e8fa2..c292a6b10269 100644
--- content/browser/compositor/offscreen_browser_compositor_output_surface.cc
+++ content/browser/compositor/offscreen_browser_compositor_output_surface.cc
@@ -33,10 +33,12 @@ OffscreenBrowserCompositorOutputSurface::
         scoped_refptr<ws::ContextProviderCommandBuffer> context,
         const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
         std::unique_ptr<viz::CompositorOverlayCandidateValidator>
-            overlay_candidate_validator)
+            overlay_candidate_validator,
+        bool shared_texture_enabled)
     : BrowserCompositorOutputSurface(std::move(context),
                                      update_vsync_parameters_callback,
                                      std::move(overlay_candidate_validator)),
+      shared_texture_enabled_(shared_texture_enabled),
       weak_ptr_factory_(this) {
   capabilities_.uses_default_gl_framebuffer = false;
 }
@@ -46,6 +48,10 @@ OffscreenBrowserCompositorOutputSurface::
   DiscardBackbuffer();
 }
 
+void* OffscreenBrowserCompositorOutputSurface::GetSharedTexture() const {
+  return (void*)shared_handle_;
+}
+
 void OffscreenBrowserCompositorOutputSurface::BindToClient(
     viz::OutputSurfaceClient* client) {
   DCHECK(client);
@@ -54,42 +60,72 @@ void OffscreenBrowserCompositorOutputSurface::BindToClient(
 }
 
 void OffscreenBrowserCompositorOutputSurface::EnsureBackbuffer() {
-  bool update_source_texture = !reflector_texture_ || reflector_changed_;
-  reflector_changed_ = false;
-  if (!reflector_texture_) {
-    reflector_texture_.reset(new ReflectorTexture(context_provider()));
-
-    GLES2Interface* gl = context_provider_->ContextGL();
-
-    const int max_texture_size =
-        context_provider_->ContextCapabilities().max_texture_size;
-    int texture_width = std::min(max_texture_size, reshape_size_.width());
-    int texture_height = std::min(max_texture_size, reshape_size_.height());
-
-    gl->BindTexture(GL_TEXTURE_2D, reflector_texture_->texture_id());
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-    gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
-    gl->TexImage2D(GL_TEXTURE_2D, 0, GLInternalFormat(kFboTextureFormat),
-                   texture_width, texture_height, 0,
-                   GLDataFormat(kFboTextureFormat),
-                   GLDataType(kFboTextureFormat), nullptr);
+  GLES2Interface* gl = context_provider_->ContextGL();
+
+  const int max_texture_size =
+      context_provider_->ContextCapabilities().max_texture_size;
+  int texture_width = std::min(max_texture_size, reshape_size_.width());
+  int texture_height = std::min(max_texture_size, reshape_size_.height());
+
+  GLuint color_attachment = 0;
+
+  if (shared_texture_enabled_) {
+    if (!shared_handle_ && (texture_width > 0) && (texture_height > 0)) {
+      gl->GenTextures(1, &shared_texture_);
+      gl->BindTexture(GL_TEXTURE_2D, shared_texture_);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      shared_handle_ = gl->CreateSharedTexture(shared_texture_, texture_width,
+                                               texture_height);
+
+      if (shared_handle_) {
+        color_attachment = shared_texture_;
+      } else {
+        gl->DeleteTextures(1, &shared_texture_);
+        shared_texture_ = 0;
+      }
+    }
+  } else {
+    // The shared texture code above in theory could work with the reflector
+    // texture However, there were issues making associating it a shared surface
+    // and then attaching it to the FBO (incomplete?)
+    bool update_source_texture = !reflector_texture_ || reflector_changed_;
+    reflector_changed_ = false;
+    if (!reflector_texture_) {
+      reflector_texture_.reset(new ReflectorTexture(context_provider()));
+
+      gl->BindTexture(GL_TEXTURE_2D, reflector_texture_->texture_id());
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+      gl->TexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+      gl->TexImage2D(GL_TEXTURE_2D, 0, GLInternalFormat(kFboTextureFormat),
+                     texture_width, texture_height, 0,
+                     GLDataFormat(kFboTextureFormat),
+                     GLDataType(kFboTextureFormat), nullptr);
+
+      color_attachment = reflector_texture_->texture_id();
+
+      // The reflector may be created later or detached and re-attached,
+      // so don't assume it always exists. For example, ChromeOS always
+      // creates a reflector asynchronosly when creating this for software
+      // mirroring.  See |DisplayManager::CreateMirrorWindowAsyncIfAny|.
+      if (reflector_ && update_source_texture)
+        reflector_->OnSourceTextureMailboxUpdated(
+            reflector_texture_->mailbox());
+    }
+  }
+
+  if (color_attachment) {
     if (!fbo_)
       gl->GenFramebuffers(1, &fbo_);
 
     gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
     gl->FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
-                             GL_TEXTURE_2D, reflector_texture_->texture_id(),
-                             0);
+                             GL_TEXTURE_2D, color_attachment, 0);
   }
-
-  // The reflector may be created later or detached and re-attached,
-  // so don't assume it always exists. For example, ChromeOS always
-  // creates a reflector asynchronosly when creating this for software
-  // mirroring.  See |DisplayManager::CreateMirrorWindowAsyncIfAny|.
-  if (reflector_ && update_source_texture)
-    reflector_->OnSourceTextureMailboxUpdated(reflector_texture_->mailbox());
 }
 
 void OffscreenBrowserCompositorOutputSurface::DiscardBackbuffer() {
@@ -101,6 +137,16 @@ void OffscreenBrowserCompositorOutputSurface::DiscardBackbuffer() {
       reflector_->OnSourceTextureMailboxUpdated(nullptr);
   }
 
+  if (shared_handle_) {
+    gl->DeleteSharedTexture(shared_handle_);
+    shared_handle_ = 0ull;
+  }
+
+  if (shared_texture_) {
+    gl->DeleteTextures(1, &shared_texture_);
+    shared_texture_ = 0;
+  }
+
   if (fbo_) {
     gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
     gl->DeleteFramebuffers(1, &fbo_);
@@ -125,15 +171,20 @@ void OffscreenBrowserCompositorOutputSurface::Reshape(
 }
 
 void OffscreenBrowserCompositorOutputSurface::BindFramebuffer() {
-  bool need_to_bind = !!reflector_texture_.get();
+  GLES2Interface* gl = context_provider_->ContextGL();
 
+  bool need_to_bind = !!reflector_texture_.get();
   EnsureBackbuffer();
-  DCHECK(reflector_texture_.get());
   DCHECK(fbo_);
 
-  if (need_to_bind) {
-    GLES2Interface* gl = context_provider_->ContextGL();
+  if (shared_handle_) {
     gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
+    gl->LockSharedTexture(shared_handle_);
+  } else {
+    DCHECK(reflector_texture_.get());
+    if (need_to_bind) {
+      gl->BindFramebuffer(GL_FRAMEBUFFER, fbo_);
+    }
   }
 }
 
@@ -154,6 +205,12 @@ void OffscreenBrowserCompositorOutputSurface::SwapBuffers(
   // The original implementation had a flickering issue (crbug.com/515332).
   gpu::gles2::GLES2Interface* gl = context_provider_->ContextGL();
 
+  // If using a shared texture we need to Flush.
+  if (shared_handle_) {
+    gl->UnlockSharedTexture(shared_handle_);
+    gl->Flush();
+  }
+
   gpu::SyncToken sync_token;
   gl->GenUnverifiedSyncTokenCHROMIUM(sync_token.GetData());
   context_provider_->ContextSupport()->SignalSyncToken(
@@ -195,8 +252,11 @@ void OffscreenBrowserCompositorOutputSurface::OnSwapBuffersComplete(
     bool need_presentation_feedback) {
   latency_tracker_.OnGpuSwapBuffersCompleted(latency_info);
   client_->DidReceiveSwapBuffersAck();
-  if (need_presentation_feedback)
-    client_->DidReceivePresentationFeedback(gfx::PresentationFeedback());
+  if (need_presentation_feedback) {
+    gfx::PresentationFeedback feedback;
+    feedback.timestamp = base::TimeTicks::Now();
+    client_->DidReceivePresentationFeedback(feedback);
+  }
 }
 
 #if BUILDFLAG(ENABLE_VULKAN)
diff --git content/browser/compositor/offscreen_browser_compositor_output_surface.h content/browser/compositor/offscreen_browser_compositor_output_surface.h
index 582388dd576c..103c9374e535 100644
--- content/browser/compositor/offscreen_browser_compositor_output_surface.h
+++ content/browser/compositor/offscreen_browser_compositor_output_surface.h
@@ -32,7 +32,8 @@ class OffscreenBrowserCompositorOutputSurface
       scoped_refptr<ws::ContextProviderCommandBuffer> context,
       const UpdateVSyncParametersCallback& update_vsync_parameters_callback,
       std::unique_ptr<viz::CompositorOverlayCandidateValidator>
-          overlay_candidate_validator);
+          overlay_candidate_validator,
+      bool shared_texture_enabled);
 
   ~OffscreenBrowserCompositorOutputSurface() override;
 
@@ -54,6 +55,8 @@ class OffscreenBrowserCompositorOutputSurface
   gfx::BufferFormat GetOverlayBufferFormat() const override;
   uint32_t GetFramebufferCopyTextureFormat() override;
 
+  void* GetSharedTexture() const override;
+
   // BrowserCompositorOutputSurface implementation.
   void OnReflectorChanged() override;
 
@@ -63,6 +66,8 @@ class OffscreenBrowserCompositorOutputSurface
 
   unsigned UpdateGpuFence() override;
 
+  void NotifyRenderHost(const std::vector<ui::LatencyInfo>& latency_info);
+
   void OnSwapBuffersComplete(const std::vector<ui::LatencyInfo>& latency_info,
                              bool need_presentation_feedback);
 
@@ -71,6 +76,11 @@ class OffscreenBrowserCompositorOutputSurface
   uint32_t fbo_ = 0;
   bool reflector_changed_ = false;
   std::unique_ptr<ReflectorTexture> reflector_texture_;
+
+  bool shared_texture_enabled_ = false;
+  uint64_t shared_handle_ = 0ull;
+  uint32_t shared_texture_ = 0;
+
   ui::LatencyTracker latency_tracker_;
   base::WeakPtrFactory<OffscreenBrowserCompositorOutputSurface>
       weak_ptr_factory_;
diff --git gpu/GLES2/gl2chromium_autogen.h gpu/GLES2/gl2chromium_autogen.h
index 0fafe61704a0..a9bb72f3494b 100644
--- gpu/GLES2/gl2chromium_autogen.h
+++ gpu/GLES2/gl2chromium_autogen.h
@@ -405,6 +405,10 @@
   GLES2_GET_FUN(CreateClientGpuFenceCHROMIUM)
 #define glWaitGpuFenceCHROMIUM GLES2_GET_FUN(WaitGpuFenceCHROMIUM)
 #define glDestroyGpuFenceCHROMIUM GLES2_GET_FUN(DestroyGpuFenceCHROMIUM)
+#define glCreateSharedTexture GLES2_GET_FUN(CreateSharedTexture)
+#define glLockSharedTexture GLES2_GET_FUN(LockSharedTexture)
+#define glUnlockSharedTexture GLES2_GET_FUN(UnlockSharedTexture)
+#define glDeleteSharedTexture GLES2_GET_FUN(DeleteSharedTexture)
 #define glInvalidateReadbackBufferShadowDataCHROMIUM \
   GLES2_GET_FUN(InvalidateReadbackBufferShadowDataCHROMIUM)
 #define glFramebufferTextureMultiviewLayeredANGLE \
diff --git gpu/command_buffer/build_gles2_cmd_buffer.py gpu/command_buffer/build_gles2_cmd_buffer.py
index 34e0d4529183..fa6a28461a73 100755
--- gpu/command_buffer/build_gles2_cmd_buffer.py
+++ gpu/command_buffer/build_gles2_cmd_buffer.py
@@ -4085,6 +4085,35 @@ _FUNCTION_INFO = {
     'extension': 'CHROMIUM_gpu_fence',
     'extension_flag': 'chromium_gpu_fence',
   },
+  'CreateSharedTexture': {
+    'type': 'Custom',
+    'data_transfer_methods': ['shm'],
+    'cmd_args': 'GLint texture_id, GLint width, '
+                'GLint height, GLuint64* result',
+    'result': ['GLuint64'],
+    'unit_test': False,
+    'impl_func': False,
+    'client_test': False,
+    'extension': True,
+  },
+  'LockSharedTexture': {
+    'type': 'Custom',
+    'unit_test': False,
+    'client_test': False,
+    'extension': True,
+  },
+  'UnlockSharedTexture': {
+    'type': 'Custom',
+    'unit_test': False,
+    'client_test': False,
+    'extension': True,
+  },
+  'DeleteSharedTexture': {
+    'type': 'Custom',
+    'unit_test': False,
+    'client_test': False,
+    'extension': True,
+  },
   'UnpremultiplyAndDitherCopyCHROMIUM': {
     'decoder_func': 'DoUnpremultiplyAndDitherCopyCHROMIUM',
     'cmd_args': 'GLuint source_id, GLuint dest_id, GLint x, GLint y, '
diff --git gpu/command_buffer/client/gles2_c_lib_autogen.h gpu/command_buffer/client/gles2_c_lib_autogen.h
index 74b68fa62a5f..42f7b3216c9d 100644
--- gpu/command_buffer/client/gles2_c_lib_autogen.h
+++ gpu/command_buffer/client/gles2_c_lib_autogen.h
@@ -1818,6 +1818,20 @@ void GL_APIENTRY GLES2WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) {
 void GL_APIENTRY GLES2DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) {
   gles2::GetGLContext()->DestroyGpuFenceCHROMIUM(gpu_fence_id);
 }
+GLuint64 GL_APIENTRY GLES2CreateSharedTexture(GLuint texture_id,
+                                              GLsizei width,
+                                              GLsizei height) {
+  return gles2::GetGLContext()->CreateSharedTexture(texture_id, width, height);
+}
+void GL_APIENTRY GLES2LockSharedTexture(GLuint64 shared_handle) {
+  gles2::GetGLContext()->LockSharedTexture(shared_handle);
+}
+void GL_APIENTRY GLES2UnlockSharedTexture(GLuint64 shared_handle) {
+  gles2::GetGLContext()->UnlockSharedTexture(shared_handle);
+}
+void GL_APIENTRY GLES2DeleteSharedTexture(GLuint64 shared_handle) {
+  gles2::GetGLContext()->DeleteSharedTexture(shared_handle);
+}
 void GL_APIENTRY
 GLES2InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) {
   gles2::GetGLContext()->InvalidateReadbackBufferShadowDataCHROMIUM(buffer_id);
@@ -3299,6 +3313,22 @@ extern const NameToFunc g_gles2_function_table[] = {
         "glDestroyGpuFenceCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(glDestroyGpuFenceCHROMIUM),
     },
+    {
+        "glCreateSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glCreateSharedTexture),
+    },
+    {
+        "glLockSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glLockSharedTexture),
+    },
+    {
+        "glUnlockSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glUnlockSharedTexture),
+    },
+    {
+        "glDeleteSharedTexture",
+        reinterpret_cast<GLES2FunctionPointer>(glDeleteSharedTexture),
+    },
     {
         "glInvalidateReadbackBufferShadowDataCHROMIUM",
         reinterpret_cast<GLES2FunctionPointer>(
diff --git gpu/command_buffer/client/gles2_cmd_helper_autogen.h gpu/command_buffer/client/gles2_cmd_helper_autogen.h
index f2da35b038e1..3989691bda6d 100644
--- gpu/command_buffer/client/gles2_cmd_helper_autogen.h
+++ gpu/command_buffer/client/gles2_cmd_helper_autogen.h
@@ -3364,6 +3364,42 @@ void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) {
   }
 }
 
+void CreateSharedTexture(GLint texture_id,
+                         GLint width,
+                         GLint height,
+                         uint32_t result_shm_id,
+                         uint32_t result_shm_offset) {
+  gles2::cmds::CreateSharedTexture* c =
+      GetCmdSpace<gles2::cmds::CreateSharedTexture>();
+  if (c) {
+    c->Init(texture_id, width, height, result_shm_id, result_shm_offset);
+  }
+}
+
+void LockSharedTexture(GLuint64 shared_handle) {
+  gles2::cmds::LockSharedTexture* c =
+      GetCmdSpace<gles2::cmds::LockSharedTexture>();
+  if (c) {
+    c->Init(shared_handle);
+  }
+}
+
+void UnlockSharedTexture(GLuint64 shared_handle) {
+  gles2::cmds::UnlockSharedTexture* c =
+      GetCmdSpace<gles2::cmds::UnlockSharedTexture>();
+  if (c) {
+    c->Init(shared_handle);
+  }
+}
+
+void DeleteSharedTexture(GLuint64 shared_handle) {
+  gles2::cmds::DeleteSharedTexture* c =
+      GetCmdSpace<gles2::cmds::DeleteSharedTexture>();
+  if (c) {
+    c->Init(shared_handle);
+  }
+}
+
 void SetReadbackBufferShadowAllocationINTERNAL(GLuint buffer_id,
                                                GLint shm_id,
                                                GLuint shm_offset,
diff --git gpu/command_buffer/client/gles2_implementation.cc gpu/command_buffer/client/gles2_implementation.cc
index 0e1dd204db7d..c5fc6a8a82b6 100644
--- gpu/command_buffer/client/gles2_implementation.cc
+++ gpu/command_buffer/client/gles2_implementation.cc
@@ -7286,6 +7286,22 @@ void GLES2Implementation::Viewport(GLint x,
   CheckGLError();
 }
 
+GLuint64 GLES2Implementation::CreateSharedTexture(GLuint texture_id,
+                                                  GLsizei width,
+                                                  GLsizei height) {
+  typedef cmds::CreateSharedTexture::Result Result;
+  auto result = GetResultAs<Result>();
+  if (!result) {
+    return 0;
+  }
+  *result = 0;
+  helper_->CreateSharedTexture(texture_id, width, height, GetResultShmId(),
+                               result.offset());
+
+  WaitForCmd();
+  return *result;
+}
+
 void GLES2Implementation::IssueBeginQuery(GLenum target,
                                           GLuint id,
                                           uint32_t sync_data_shm_id,
diff --git gpu/command_buffer/client/gles2_implementation_autogen.h gpu/command_buffer/client/gles2_implementation_autogen.h
index b520b91d1398..d9c1a7ec7cf3 100644
--- gpu/command_buffer/client/gles2_implementation_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_autogen.h
@@ -1276,6 +1276,16 @@ void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 
 void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 
+GLuint64 CreateSharedTexture(GLuint texture_id,
+                             GLsizei width,
+                             GLsizei height) override;
+
+void LockSharedTexture(GLuint64 shared_handle) override;
+
+void UnlockSharedTexture(GLuint64 shared_handle) override;
+
+void DeleteSharedTexture(GLuint64 shared_handle) override;
+
 void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) override;
 
 void FramebufferTextureMultiviewLayeredANGLE(GLenum target,
diff --git gpu/command_buffer/client/gles2_implementation_impl_autogen.h gpu/command_buffer/client/gles2_implementation_impl_autogen.h
index 45060ce79d7f..d83ce6e78a04 100644
--- gpu/command_buffer/client/gles2_implementation_impl_autogen.h
+++ gpu/command_buffer/client/gles2_implementation_impl_autogen.h
@@ -3675,6 +3675,30 @@ void GLES2Implementation::DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) {
   CheckGLError();
 }
 
+void GLES2Implementation::LockSharedTexture(GLuint64 shared_handle) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glLockSharedTexture("
+                     << shared_handle << ")");
+  helper_->LockSharedTexture(shared_handle);
+  CheckGLError();
+}
+
+void GLES2Implementation::UnlockSharedTexture(GLuint64 shared_handle) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glUnlockSharedTexture("
+                     << shared_handle << ")");
+  helper_->UnlockSharedTexture(shared_handle);
+  CheckGLError();
+}
+
+void GLES2Implementation::DeleteSharedTexture(GLuint64 shared_handle) {
+  GPU_CLIENT_SINGLE_THREAD_CHECK();
+  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glDeleteSharedTexture("
+                     << shared_handle << ")");
+  helper_->DeleteSharedTexture(shared_handle);
+  CheckGLError();
+}
+
 void GLES2Implementation::FramebufferTextureMultiviewLayeredANGLE(
     GLenum target,
     GLenum attachment,
diff --git gpu/command_buffer/client/gles2_interface_autogen.h gpu/command_buffer/client/gles2_interface_autogen.h
index 181c4a60d294..4ce350b3633a 100644
--- gpu/command_buffer/client/gles2_interface_autogen.h
+++ gpu/command_buffer/client/gles2_interface_autogen.h
@@ -950,6 +950,12 @@ virtual GLuint CreateGpuFenceCHROMIUM() = 0;
 virtual GLuint CreateClientGpuFenceCHROMIUM(ClientGpuFence source) = 0;
 virtual void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) = 0;
 virtual void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) = 0;
+virtual GLuint64 CreateSharedTexture(GLuint texture_id,
+                                     GLsizei width,
+                                     GLsizei height) = 0;
+virtual void LockSharedTexture(GLuint64 shared_handle) = 0;
+virtual void UnlockSharedTexture(GLuint64 shared_handle) = 0;
+virtual void DeleteSharedTexture(GLuint64 shared_handle) = 0;
 virtual void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) = 0;
 virtual void FramebufferTextureMultiviewLayeredANGLE(GLenum target,
                                                      GLenum attachment,
diff --git gpu/command_buffer/client/gles2_interface_stub_autogen.h gpu/command_buffer/client/gles2_interface_stub_autogen.h
index 3d4833bb8ff0..43074fe25fd8 100644
--- gpu/command_buffer/client/gles2_interface_stub_autogen.h
+++ gpu/command_buffer/client/gles2_interface_stub_autogen.h
@@ -920,6 +920,12 @@ GLuint CreateGpuFenceCHROMIUM() override;
 GLuint CreateClientGpuFenceCHROMIUM(ClientGpuFence source) override;
 void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
+GLuint64 CreateSharedTexture(GLuint texture_id,
+                             GLsizei width,
+                             GLsizei height) override;
+void LockSharedTexture(GLuint64 shared_handle) override;
+void UnlockSharedTexture(GLuint64 shared_handle) override;
+void DeleteSharedTexture(GLuint64 shared_handle) override;
 void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) override;
 void FramebufferTextureMultiviewLayeredANGLE(GLenum target,
                                              GLenum attachment,
diff --git gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
index f5ebca07a38f..94a0a254f5ba 100644
--- gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
+++ gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
@@ -1235,6 +1235,14 @@ GLuint GLES2InterfaceStub::CreateClientGpuFenceCHROMIUM(
 }
 void GLES2InterfaceStub::WaitGpuFenceCHROMIUM(GLuint /* gpu_fence_id */) {}
 void GLES2InterfaceStub::DestroyGpuFenceCHROMIUM(GLuint /* gpu_fence_id */) {}
+GLuint64 GLES2InterfaceStub::CreateSharedTexture(GLuint /* texture_id */,
+                                                 GLsizei /* width */,
+                                                 GLsizei /* height */) {
+  return 0;
+}
+void GLES2InterfaceStub::LockSharedTexture(GLuint64 /* shared_handle */) {}
+void GLES2InterfaceStub::UnlockSharedTexture(GLuint64 /* shared_handle */) {}
+void GLES2InterfaceStub::DeleteSharedTexture(GLuint64 /* shared_handle */) {}
 void GLES2InterfaceStub::InvalidateReadbackBufferShadowDataCHROMIUM(
     GLuint /* buffer_id */) {}
 void GLES2InterfaceStub::FramebufferTextureMultiviewLayeredANGLE(
diff --git gpu/command_buffer/client/gles2_trace_implementation_autogen.h gpu/command_buffer/client/gles2_trace_implementation_autogen.h
index caa12933ef3d..60e009ce03b9 100644
--- gpu/command_buffer/client/gles2_trace_implementation_autogen.h
+++ gpu/command_buffer/client/gles2_trace_implementation_autogen.h
@@ -920,6 +920,12 @@ GLuint CreateGpuFenceCHROMIUM() override;
 GLuint CreateClientGpuFenceCHROMIUM(ClientGpuFence source) override;
 void WaitGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
 void DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) override;
+GLuint64 CreateSharedTexture(GLuint texture_id,
+                             GLsizei width,
+                             GLsizei height) override;
+void LockSharedTexture(GLuint64 shared_handle) override;
+void UnlockSharedTexture(GLuint64 shared_handle) override;
+void DeleteSharedTexture(GLuint64 shared_handle) override;
 void InvalidateReadbackBufferShadowDataCHROMIUM(GLuint buffer_id) override;
 void FramebufferTextureMultiviewLayeredANGLE(GLenum target,
                                              GLenum attachment,
diff --git gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
index 6ddd340314ad..3840254d80d7 100644
--- gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
+++ gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
@@ -2637,6 +2637,28 @@ void GLES2TraceImplementation::DestroyGpuFenceCHROMIUM(GLuint gpu_fence_id) {
   gl_->DestroyGpuFenceCHROMIUM(gpu_fence_id);
 }
 
+GLuint64 GLES2TraceImplementation::CreateSharedTexture(GLuint texture_id,
+                                                       GLsizei width,
+                                                       GLsizei height) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::CreateSharedTexture");
+  return gl_->CreateSharedTexture(texture_id, width, height);
+}
+
+void GLES2TraceImplementation::LockSharedTexture(GLuint64 shared_handle) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::LockSharedTexture");
+  gl_->LockSharedTexture(shared_handle);
+}
+
+void GLES2TraceImplementation::UnlockSharedTexture(GLuint64 shared_handle) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::UnlockSharedTexture");
+  gl_->UnlockSharedTexture(shared_handle);
+}
+
+void GLES2TraceImplementation::DeleteSharedTexture(GLuint64 shared_handle) {
+  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::DeleteSharedTexture");
+  gl_->DeleteSharedTexture(shared_handle);
+}
+
 void GLES2TraceImplementation::InvalidateReadbackBufferShadowDataCHROMIUM(
     GLuint buffer_id) {
   TRACE_EVENT_BINARY_EFFICIENT0(
diff --git gpu/command_buffer/common/gles2_cmd_format_autogen.h gpu/command_buffer/common/gles2_cmd_format_autogen.h
index 76ee6074b51a..1644f27a20d6 100644
--- gpu/command_buffer/common/gles2_cmd_format_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_format_autogen.h
@@ -16576,6 +16576,193 @@ static_assert(offsetof(DestroyGpuFenceCHROMIUM, header) == 0,
 static_assert(offsetof(DestroyGpuFenceCHROMIUM, gpu_fence_id) == 4,
               "offset of DestroyGpuFenceCHROMIUM gpu_fence_id should be 4");
 
+struct CreateSharedTexture {
+  typedef CreateSharedTexture ValueType;
+  static const CommandId kCmdId = kCreateSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  typedef GLuint64 Result;
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLint _texture_id,
+            GLint _width,
+            GLint _height,
+            uint32_t _result_shm_id,
+            uint32_t _result_shm_offset) {
+    SetHeader();
+    texture_id = _texture_id;
+    width = _width;
+    height = _height;
+    result_shm_id = _result_shm_id;
+    result_shm_offset = _result_shm_offset;
+  }
+
+  void* Set(void* cmd,
+            GLint _texture_id,
+            GLint _width,
+            GLint _height,
+            uint32_t _result_shm_id,
+            uint32_t _result_shm_offset) {
+    static_cast<ValueType*>(cmd)->Init(_texture_id, _width, _height,
+                                       _result_shm_id, _result_shm_offset);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  gpu::CommandHeader header;
+  int32_t texture_id;
+  int32_t width;
+  int32_t height;
+  uint32_t result_shm_id;
+  uint32_t result_shm_offset;
+};
+
+static_assert(sizeof(CreateSharedTexture) == 24,
+              "size of CreateSharedTexture should be 24");
+static_assert(offsetof(CreateSharedTexture, header) == 0,
+              "offset of CreateSharedTexture header should be 0");
+static_assert(offsetof(CreateSharedTexture, texture_id) == 4,
+              "offset of CreateSharedTexture texture_id should be 4");
+static_assert(offsetof(CreateSharedTexture, width) == 8,
+              "offset of CreateSharedTexture width should be 8");
+static_assert(offsetof(CreateSharedTexture, height) == 12,
+              "offset of CreateSharedTexture height should be 12");
+static_assert(offsetof(CreateSharedTexture, result_shm_id) == 16,
+              "offset of CreateSharedTexture result_shm_id should be 16");
+static_assert(offsetof(CreateSharedTexture, result_shm_offset) == 20,
+              "offset of CreateSharedTexture result_shm_offset should be 20");
+
+struct LockSharedTexture {
+  typedef LockSharedTexture ValueType;
+  static const CommandId kCmdId = kLockSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _shared_handle) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_shared_handle),
+                                    &shared_handle_0, &shared_handle_1);
+  }
+
+  void* Set(void* cmd, GLuint64 _shared_handle) {
+    static_cast<ValueType*>(cmd)->Init(_shared_handle);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 shared_handle() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(shared_handle_0, shared_handle_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t shared_handle_0;
+  uint32_t shared_handle_1;
+};
+
+static_assert(sizeof(LockSharedTexture) == 12,
+              "size of LockSharedTexture should be 12");
+static_assert(offsetof(LockSharedTexture, header) == 0,
+              "offset of LockSharedTexture header should be 0");
+static_assert(offsetof(LockSharedTexture, shared_handle_0) == 4,
+              "offset of LockSharedTexture shared_handle_0 should be 4");
+static_assert(offsetof(LockSharedTexture, shared_handle_1) == 8,
+              "offset of LockSharedTexture shared_handle_1 should be 8");
+
+struct UnlockSharedTexture {
+  typedef UnlockSharedTexture ValueType;
+  static const CommandId kCmdId = kUnlockSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _shared_handle) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_shared_handle),
+                                    &shared_handle_0, &shared_handle_1);
+  }
+
+  void* Set(void* cmd, GLuint64 _shared_handle) {
+    static_cast<ValueType*>(cmd)->Init(_shared_handle);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 shared_handle() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(shared_handle_0, shared_handle_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t shared_handle_0;
+  uint32_t shared_handle_1;
+};
+
+static_assert(sizeof(UnlockSharedTexture) == 12,
+              "size of UnlockSharedTexture should be 12");
+static_assert(offsetof(UnlockSharedTexture, header) == 0,
+              "offset of UnlockSharedTexture header should be 0");
+static_assert(offsetof(UnlockSharedTexture, shared_handle_0) == 4,
+              "offset of UnlockSharedTexture shared_handle_0 should be 4");
+static_assert(offsetof(UnlockSharedTexture, shared_handle_1) == 8,
+              "offset of UnlockSharedTexture shared_handle_1 should be 8");
+
+struct DeleteSharedTexture {
+  typedef DeleteSharedTexture ValueType;
+  static const CommandId kCmdId = kDeleteSharedTexture;
+  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
+  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(3);
+
+  static uint32_t ComputeSize() {
+    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
+  }
+
+  void SetHeader() { header.SetCmd<ValueType>(); }
+
+  void Init(GLuint64 _shared_handle) {
+    SetHeader();
+    GLES2Util::MapUint64ToTwoUint32(static_cast<uint64_t>(_shared_handle),
+                                    &shared_handle_0, &shared_handle_1);
+  }
+
+  void* Set(void* cmd, GLuint64 _shared_handle) {
+    static_cast<ValueType*>(cmd)->Init(_shared_handle);
+    return NextCmdAddress<ValueType>(cmd);
+  }
+
+  GLuint64 shared_handle() const volatile {
+    return static_cast<GLuint64>(
+        GLES2Util::MapTwoUint32ToUint64(shared_handle_0, shared_handle_1));
+  }
+
+  gpu::CommandHeader header;
+  uint32_t shared_handle_0;
+  uint32_t shared_handle_1;
+};
+
+static_assert(sizeof(DeleteSharedTexture) == 12,
+              "size of DeleteSharedTexture should be 12");
+static_assert(offsetof(DeleteSharedTexture, header) == 0,
+              "offset of DeleteSharedTexture header should be 0");
+static_assert(offsetof(DeleteSharedTexture, shared_handle_0) == 4,
+              "offset of DeleteSharedTexture shared_handle_0 should be 4");
+static_assert(offsetof(DeleteSharedTexture, shared_handle_1) == 8,
+              "offset of DeleteSharedTexture shared_handle_1 should be 8");
+
 struct SetReadbackBufferShadowAllocationINTERNAL {
   typedef SetReadbackBufferShadowAllocationINTERNAL ValueType;
   static const CommandId kCmdId = kSetReadbackBufferShadowAllocationINTERNAL;
diff --git gpu/command_buffer/common/gles2_cmd_format_test_autogen.h gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
index 52f445fe307f..97edefaffa39 100644
--- gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
@@ -5514,6 +5514,52 @@ TEST_F(GLES2FormatTest, DestroyGpuFenceCHROMIUM) {
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
+TEST_F(GLES2FormatTest, CreateSharedTexture) {
+  cmds::CreateSharedTexture& cmd = *GetBufferAs<cmds::CreateSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLint>(11), static_cast<GLint>(12),
+                           static_cast<GLint>(13), static_cast<uint32_t>(14),
+                           static_cast<uint32_t>(15));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::CreateSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLint>(11), cmd.texture_id);
+  EXPECT_EQ(static_cast<GLint>(12), cmd.width);
+  EXPECT_EQ(static_cast<GLint>(13), cmd.height);
+  EXPECT_EQ(static_cast<uint32_t>(14), cmd.result_shm_id);
+  EXPECT_EQ(static_cast<uint32_t>(15), cmd.result_shm_offset);
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, LockSharedTexture) {
+  cmds::LockSharedTexture& cmd = *GetBufferAs<cmds::LockSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint64>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::LockSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.shared_handle());
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, UnlockSharedTexture) {
+  cmds::UnlockSharedTexture& cmd = *GetBufferAs<cmds::UnlockSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint64>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::UnlockSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.shared_handle());
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
+TEST_F(GLES2FormatTest, DeleteSharedTexture) {
+  cmds::DeleteSharedTexture& cmd = *GetBufferAs<cmds::DeleteSharedTexture>();
+  void* next_cmd = cmd.Set(&cmd, static_cast<GLuint64>(11));
+  EXPECT_EQ(static_cast<uint32_t>(cmds::DeleteSharedTexture::kCmdId),
+            cmd.header.command);
+  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
+  EXPECT_EQ(static_cast<GLuint64>(11), cmd.shared_handle());
+  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
+}
+
 TEST_F(GLES2FormatTest, SetReadbackBufferShadowAllocationINTERNAL) {
   cmds::SetReadbackBufferShadowAllocationINTERNAL& cmd =
       *GetBufferAs<cmds::SetReadbackBufferShadowAllocationINTERNAL>();
diff --git gpu/command_buffer/common/gles2_cmd_ids_autogen.h gpu/command_buffer/common/gles2_cmd_ids_autogen.h
index 753b9c309604..6958e6c5cd00 100644
--- gpu/command_buffer/common/gles2_cmd_ids_autogen.h
+++ gpu/command_buffer/common/gles2_cmd_ids_autogen.h
@@ -351,7 +351,11 @@
   OP(MaxShaderCompilerThreadsKHR)                          /* 592 */ \
   OP(CreateAndTexStorage2DSharedImageINTERNALImmediate)    /* 593 */ \
   OP(BeginSharedImageAccessDirectCHROMIUM)                 /* 594 */ \
-  OP(EndSharedImageAccessDirectCHROMIUM)                   /* 595 */
+  OP(EndSharedImageAccessDirectCHROMIUM)                   /* 595 */ \
+  OP(CreateSharedTexture)                                  /* 596 */ \
+  OP(LockSharedTexture)                                    /* 597 */ \
+  OP(UnlockSharedTexture)                                  /* 598 */ \
+  OP(DeleteSharedTexture)                                  /* 599 */
 
 enum CommandId {
   kOneBeforeStartPoint =
diff --git gpu/command_buffer/gles2_cmd_buffer_functions.txt gpu/command_buffer/gles2_cmd_buffer_functions.txt
index 7a14db0357ad..89258f5ec0dd 100644
--- gpu/command_buffer/gles2_cmd_buffer_functions.txt
+++ gpu/command_buffer/gles2_cmd_buffer_functions.txt
@@ -396,6 +396,12 @@ GL_APICALL GLuint       GL_APIENTRY glCreateClientGpuFenceCHROMIUM (ClientGpuFen
 GL_APICALL void         GL_APIENTRY glWaitGpuFenceCHROMIUM (GLuint gpu_fence_id);
 GL_APICALL void         GL_APIENTRY glDestroyGpuFenceCHROMIUM (GLuint gpu_fence_id);
 
+// shared handle extensions
+GL_APICALL GLuint64     GL_APIENTRY glCreateSharedTexture (GLuint texture_id, GLsizei width, GLsizei height);
+GL_APICALL void         GL_APIENTRY glLockSharedTexture (GLuint64 shared_handle);
+GL_APICALL void         GL_APIENTRY glUnlockSharedTexture (GLuint64 shared_handle);
+GL_APICALL void         GL_APIENTRY glDeleteSharedTexture (GLuint64 shared_handle);
+
 // Extension CHROMIUM_nonblocking_readback
 GL_APICALL void         GL_APIENTRY glInvalidateReadbackBufferShadowDataCHROMIUM (GLidBuffer buffer_id);
 // (used for CHROMIUM_nonblocking_readback implementation)
diff --git gpu/command_buffer/service/BUILD.gn gpu/command_buffer/service/BUILD.gn
index 73f1cd7a60af..2bde69b3842b 100644
--- gpu/command_buffer/service/BUILD.gn
+++ gpu/command_buffer/service/BUILD.gn
@@ -106,6 +106,8 @@ target(link_target_type, "gles2_sources") {
   visibility = [ "//gpu/*" ]
 
   sources = [
+    "//cef/libcef/browser/gpu/external_texture_manager.cc",
+    "//cef/libcef/browser/gpu/external_texture_manager.h",
     "abstract_texture.h",
     "buffer_manager.cc",
     "buffer_manager.h",
diff --git gpu/command_buffer/service/gles2_cmd_decoder.cc gpu/command_buffer/service/gles2_cmd_decoder.cc
index e4be47a76448..4949935c2241 100644
--- gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -34,6 +34,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/trace_event/trace_event.h"
 #include "build/build_config.h"
+#include "cef/libcef/browser/gpu/external_texture_manager.h"
 #include "gpu/command_buffer/common/debug_marker_manager.h"
 #include "gpu/command_buffer/common/gles2_cmd_format.h"
 #include "gpu/command_buffer/common/gles2_cmd_utils.h"
@@ -888,6 +889,13 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
     return group_->mailbox_manager();
   }
 
+  ExternalTextureManager* external_texture_manager() {
+    if (!external_texture_manager_.get()) {
+      external_texture_manager_.reset(new gles2::ExternalTextureManager());
+    }
+    return external_texture_manager_.get();
+  }
+
   ImageManager* image_manager() { return group_->image_manager(); }
 
   VertexArrayManager* vertex_array_manager() {
@@ -2533,6 +2541,8 @@ class GLES2DecoderImpl : public GLES2Decoder, public ErrorStateClient {
 
   std::unique_ptr<VertexArrayManager> vertex_array_manager_;
 
+  std::unique_ptr<ExternalTextureManager> external_texture_manager_;
+
   base::flat_set<scoped_refptr<Buffer>> writes_submitted_but_not_completed_;
 
   // The format of the back buffer_
@@ -5437,6 +5447,59 @@ error::Error GLES2DecoderImpl::HandleDestroyGpuFenceCHROMIUM(
   return error::kNoError;
 }
 
+error::Error GLES2DecoderImpl::HandleCreateSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::CreateSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::CreateSharedTexture*>(cmd_data);
+  GLuint texture_id = c.texture_id;
+  uint32_t width = c.width;
+  uint32_t height = c.height;
+
+  typedef cmds::CreateSharedTexture::Result Result;
+  Result* result_dst = GetSharedMemoryAs<Result*>(
+      c.result_shm_id, c.result_shm_offset, sizeof(*result_dst));
+  if (!result_dst) {
+    return error::kOutOfBounds;
+  }
+
+  void* shared_handle = external_texture_manager()->CreateTexture(
+      texture_id, width, height, texture_manager());
+
+  *result_dst = (GLuint64)(shared_handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleLockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::LockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::LockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->LockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleUnlockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::UnlockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::UnlockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->UnlockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderImpl::HandleDeleteSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::DeleteSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::DeleteSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->DeleteTexture(handle, texture_manager());
+  return error::kNoError;
+}
+
 void GLES2DecoderImpl::CreateBackTexture() {
   for (auto it = saved_back_textures_.begin(); it != saved_back_textures_.end();
        ++it) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
index b363a2f5849d..5e5404dfb1af 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough.cc
@@ -9,6 +9,7 @@
 
 #include "base/callback.h"
 #include "base/strings/string_split.h"
+#include "cef/libcef/browser/gpu/external_texture_manager.h"
 #include "gpu/command_buffer/service/command_buffer_service.h"
 #include "gpu/command_buffer/service/decoder_client.h"
 #include "gpu/command_buffer/service/feature_info.h"
@@ -2478,6 +2479,67 @@ error::Error GLES2DecoderPassthroughImpl::CheckSwapBuffersResult(
   return error::kNoError;
 }
 
+ExternalTextureManager*
+GLES2DecoderPassthroughImpl::external_texture_manager() {
+  if (!external_texture_manager_.get()) {
+    external_texture_manager_.reset(new gles2::ExternalTextureManager());
+  }
+  return external_texture_manager_.get();
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleCreateSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::CreateSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::CreateSharedTexture*>(cmd_data);
+  GLuint texture_id = c.texture_id;
+  uint32_t width = c.width;
+  uint32_t height = c.height;
+
+  typedef cmds::CreateSharedTexture::Result Result;
+  Result* result_dst = GetSharedMemoryAs<Result*>(
+      c.result_shm_id, c.result_shm_offset, sizeof(*result_dst));
+  if (!result_dst) {
+    return error::kOutOfBounds;
+  }
+
+  void* shared_handle = external_texture_manager()->CreateTexture(
+      texture_id, width, height, nullptr);
+
+  *result_dst = (GLuint64)(shared_handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleLockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::LockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::LockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->LockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleUnlockSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::UnlockSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::UnlockSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->UnlockTexture(handle);
+  return error::kNoError;
+}
+
+error::Error GLES2DecoderPassthroughImpl::HandleDeleteSharedTexture(
+    uint32_t immediate_data_size,
+    const volatile void* cmd_data) {
+  const volatile gles2::cmds::DeleteSharedTexture& c =
+      *static_cast<const volatile gles2::cmds::DeleteSharedTexture*>(cmd_data);
+  void* handle = (void*)(c.shared_handle());
+  external_texture_manager()->DeleteTexture(handle, nullptr);
+  return error::kNoError;
+}
+
 // static
 GLES2DecoderPassthroughImpl::TextureTarget
 GLES2DecoderPassthroughImpl::GLenumToTextureTarget(GLenum target) {
diff --git gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
index 0a36589dc65d..d5f1732353b6 100644
--- gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
+++ gpu/command_buffer/service/gles2_cmd_decoder_passthrough.h
@@ -45,6 +45,7 @@ class SharedImageRepresentationGLTexturePassthrough;
 namespace gles2 {
 
 class ContextGroup;
+class ExternalTextureManager;
 class GPUTracer;
 class PassthroughAbstractTextureImpl;
 
@@ -374,6 +375,8 @@ class GPU_GLES2_EXPORT GLES2DecoderPassthroughImpl : public GLES2Decoder {
 
   void SetOptionalExtensionsRequestedForTesting(bool request_extensions);
 
+  ExternalTextureManager* external_texture_manager();
+
   void* GetScratchMemory(size_t size);
 
   template <typename T>
@@ -575,6 +578,8 @@ class GPU_GLES2_EXPORT GLES2DecoderPassthroughImpl : public GLES2Decoder {
 
   std::unique_ptr<GpuFenceManager> gpu_fence_manager_;
 
+  std::unique_ptr<ExternalTextureManager> external_texture_manager_;
+
   // State tracking of currently bound 2D textures (client IDs)
   size_t active_texture_unit_;
 
diff --git ui/compositor/compositor.cc ui/compositor/compositor.cc
index 5358941075a4..5ffd2284c437 100644
--- ui/compositor/compositor.cc
+++ ui/compositor/compositor.cc
@@ -535,6 +535,16 @@ void Compositor::OnNeedsExternalBeginFrames(bool needs_begin_frames) {
   needs_external_begin_frames_ = needs_begin_frames;
 }
 
+void* Compositor::GetSharedTexture() {
+  if (context_factory_private_)
+    return context_factory_private_->GetSharedTexture(this);
+  return nullptr;
+}
+
+void Compositor::EnableSharedTexture(bool enable) {
+  shared_texture_enabled_ = enable;
+}
+
 void Compositor::AddObserver(CompositorObserver* observer) {
   observer_list_.AddObserver(observer);
 }
diff --git ui/compositor/compositor.h ui/compositor/compositor.h
index 6f46fd5b4b57..f3508ecb257f 100644
--- ui/compositor/compositor.h
+++ ui/compositor/compositor.h
@@ -26,6 +26,7 @@
 #include "components/viz/common/surfaces/frame_sink_id.h"
 #include "components/viz/common/surfaces/local_surface_id.h"
 #include "components/viz/host/host_frame_sink_client.h"
+#include "components/viz/service/display/software_output_device.h"
 #include "third_party/skia/include/core/SkColor.h"
 #include "third_party/skia/include/core/SkMatrix44.h"
 #include "ui/compositor/compositor_animation_observer.h"
@@ -159,6 +160,8 @@ class COMPOSITOR_EXPORT ContextFactoryPrivate {
                                        const viz::BeginFrameArgs& args) = 0;
 
   virtual void SetOutputIsSecure(Compositor* compositor, bool secure) = 0;
+
+  virtual void* GetSharedTexture(ui::Compositor* compositor) = 0;
 };
 
 // This class abstracts the creation of the 3D context for the compositor. It is
@@ -194,6 +197,17 @@ class COMPOSITOR_EXPORT ContextFactory {
   virtual bool SyncTokensRequiredForDisplayCompositor() = 0;
 };
 
+class COMPOSITOR_EXPORT CompositorDelegate {
+ public:
+  virtual std::unique_ptr<viz::SoftwareOutputDevice> CreateSoftwareOutputDevice(
+      ui::Compositor* compositor) {
+    return nullptr;
+  }
+
+ protected:
+  virtual ~CompositorDelegate() {}
+};
+
 // Compositor object to take care of GPU painting.
 // A Browser compositor object is responsible for generating the final
 // displayable form of pixels comprising a single widget's contents. It draws an
@@ -235,6 +249,9 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   // Schedules a redraw of the layer tree associated with this compositor.
   void ScheduleDraw();
 
+  CompositorDelegate* delegate() const { return delegate_; }
+  void SetDelegate(CompositorDelegate* delegate) { delegate_ = delegate; }
+
   // Sets the root of the layer tree drawn by this Compositor. The root layer
   // must have no parent. The compositor's root layer is reset if the root layer
   // is destroyed. NULL can be passed to reset the root layer, in which case the
@@ -347,6 +364,10 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
     return task_runner_;
   }
 
+  void* GetSharedTexture();
+  void EnableSharedTexture(bool enable);
+  bool shared_texture_enabled() const { return shared_texture_enabled_; }
+
   // Compositor does not own observers. It is the responsibility of the
   // observer to remove itself when it is done observing.
   void AddObserver(CompositorObserver* observer);
@@ -448,6 +469,8 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   ui::ContextFactory* context_factory_;
   ui::ContextFactoryPrivate* context_factory_private_;
 
+  CompositorDelegate* delegate_ = nullptr;
+
   // The root of the Layer tree drawn by this compositor.
   Layer* root_layer_ = nullptr;
 
@@ -484,6 +507,8 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   ExternalBeginFrameClient* external_begin_frame_client_ = nullptr;
   bool needs_external_begin_frames_ = false;
 
+  bool shared_texture_enabled_ = false;
+
   const bool force_software_compositor_;
 
   // The device scale factor of the monitor that this compositor is compositing
diff --git ui/compositor/host/host_context_factory_private.cc ui/compositor/host/host_context_factory_private.cc
index e16c5490bbcb..b4297261c397 100644
--- ui/compositor/host/host_context_factory_private.cc
+++ ui/compositor/host/host_context_factory_private.cc
@@ -248,6 +248,10 @@ void HostContextFactoryPrivate::SetOutputIsSecure(Compositor* compositor,
     iter->second.display_private->SetOutputIsSecure(secure);
 }
 
+void* HostContextFactoryPrivate::GetSharedTexture(Compositor* /*compositor*/) {
+  return nullptr;
+}
+
 viz::FrameSinkManagerImpl* HostContextFactoryPrivate::GetFrameSinkManager() {
   // When running with viz there is no FrameSinkManagerImpl in the browser
   // process. FrameSinkManagerImpl runs in the GPU process instead. Anything in
diff --git ui/compositor/host/host_context_factory_private.h ui/compositor/host/host_context_factory_private.h
index 69a441e9fbc0..818ffac9fb37 100644
--- ui/compositor/host/host_context_factory_private.h
+++ ui/compositor/host/host_context_factory_private.h
@@ -72,6 +72,8 @@ class HostContextFactoryPrivate : public ContextFactoryPrivate {
   void SetOutputIsSecure(Compositor* compositor, bool secure) override;
   viz::FrameSinkManagerImpl* GetFrameSinkManager() override;
 
+  void* GetSharedTexture(ui::Compositor* compositor) override;
+
  protected:
   void set_is_gpu_compositing_disabled(bool value) {
     is_gpu_compositing_disabled_ = value;
